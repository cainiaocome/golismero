#!/usr/bin/python
# -*- coding: utf-8 -*-

"""

OpenVas manager library for OMP v4.0

This is a replacemente library of the official Openvas python library,
becasue the oficial library not work for the OMP v4.0

"""

__license__ = """
GoLismero 2.0 - The web knife - Copyright (C) 2011-2013

Authors:
  Daniel Garcia Garcia a.k.a cr0hn | cr0hn<@>cr0hn.com
  Mario Vilas | mvilas<@>gmail.com

Golismero project site: http://golismero-project.com
Golismero project mail: golismero.project<@>gmail.com


This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
"""

from golismero.api.text.text_utils import generate_random_string

import socket
import ssl
import re
from collections import Iterable


try:
    from xml.etree import cElementTree as etree
except ImportError:
    from xml.etree import ElementTree as etree

#------------------------------------------------------------------------------
#
# High level exceptions
#
#------------------------------------------------------------------------------
class OpenvasException(Exception):
    """Base class Openvas exceptions"""
    pass
#------------------------------------------------------------------------------
class OpenvasAuthFail(OpenvasException):
    """Authentication fail"""
    #----------------------------------------------------------------------
    def __init__(self, message):
        """Constructor"""

        self.message = message

        super(OpenvasAuthFail, self).__init__()



#------------------------------------------------------------------------------
class OpenvasServerError(OpenvasException):
    """Some generic error generated by the server"""
    #----------------------------------------------------------------------
    def __init__(self, message):
        """Constructor"""

        self.message = message

        super(OpenvasServerError, self).__init__()


#------------------------------------------------------------------------------
class OpenvasClientError(OpenvasException):
    """Some generic error generated by the client"""
    #----------------------------------------------------------------------
    def __init__(self, message):
        """Constructor"""

        self.message = message

        super(OpenvasClientError, self).__init__()

#------------------------------------------------------------------------------
class OpenvasProfileError(OpenvasException):
    """Profile error"""
    #----------------------------------------------------------------------
    def __init__(self, message):
        """Constructor"""

        self.message = message

        super(OpenvasClientError, self).__init__()

#------------------------------------------------------------------------------
class OpenvasTargetError(OpenvasException):
    """Target related errors"""
    #----------------------------------------------------------------------
    def __init__(self, message):
        """Constructor"""

        self.message = message

        super(OpenvasClientError, self).__init__()

#------------------------------------------------------------------------------
class OpenvasTargetError(OpenvasException):
    """Task related errors"""
    #----------------------------------------------------------------------
    def __init__(self, message):
        """Constructor"""

        self.message = message

        super(OpenvasClientError, self).__init__()


#------------------------------------------------------------------------------
class OpenvasManager(object):
    """
    High interface to mange OpenVas server.

    ..warning:

      This manager follow the the OMP 4.0

    """

    TIMEOUT = 10

    #----------------------------------------------------------------------
    def __init__(self):
        self.__manager = None


    #----------------------------------------------------------------------
    #
    # Methods to manage the OpenVas
    #
    #----------------------------------------------------------------------
    @classmethod
    def connect(cls, host, user, password, port=9390, timeout=None):
        """
        Make the connection to the Openvas server and get a manager object.

        :param host: the host where the manager are running.
        :type host: str

        :param user: user name
        :type user: str

        :param password: the password
        :type password: str

        :param port: port where the server are listen.
        :type port: int

        :return: an OpenvasManager object
        :rtype: OpenvasManager
        """
        if not isinstance(host, basestring):
            raise TypeError("Expected basestring, got '%s'" % type(host))
        if not isinstance(user, basestring):
            raise TypeError("Expected basestring, got '%s'" % type(user))
        if not isinstance(password, basestring):
            raise TypeError("Expected basestring, got '%s'" % type(password))
        if isinstance(port, int):
            if not (0 < port < 65535):
                raise ValueError("port must be between ranges: [0-65535]")
        else:
            raise TypeError("Expected int, got '%s'" % type(port))

        m_time_out = None
        if timeout:
            if isinstance(timeout, int):
                if timeout < 1:
                    raise ValueError("timeout value must be greater than 0.")
                else:
                    m_time_out = timeout
            else:
                raise TypeError("Expected int, got '%s'" % type(timeout))


        cls                    = OpenvasManager()

        # Create the manager
        try:
            cls.__manager          = OMPv4.open(host, user, password, port, timeout=m_time_out)
        except ServerError, e:
            raise OpenvasServerError("Error while connecting to the server. Error: %s" % str(e))
        except AuthFailedError:
            raise OpenvasAuthFail("Error while trying to authenticate into the server.")

        return cls

    #----------------------------------------------------------------------
    def launch_scan(self, target, profile = "Full and fast"):
        """
        Launch a new audit in the OpenVas

        :param target: target to audit
        :type target: str

        :param profile: scan profile in the Openvas server
        :type profile: str

        :return: ID of the audit
        :rtype: str
        """
        if not (isinstance(target, basestring) or isinstance(target, Iterable)):
            raise TypeError("Expected basestring or iterable, got '%s'" % type(target))
        if not isinstance(profile, basestring):
            raise TypeError("Expected basestring, got '%s'" % type(profile))


        #
        # Generate the random names used
        #
        m_target_name = "golismero_target_%s" % generate_random_string(20)
        m_job_name    = "golismero_scan_%s" % generate_random_string(20)

        #
        # Create the target
        #
        try:
            m_target_id = self.__manager.create_target(m_target_name, target, "Temportal target from golismero Openvas plugin")
        except ServerError, e:
            raise OpenvasTargetError("The target already exits on the server. Error: %s" % e.message)

        # Get the profile Id by their name
        m_profile_id      = None
        try:
            tmp           = self.__manager.get_configs_ids(profile)
            m_profile_id  = tmp[profile]
        except ServerError:
            raise OpenvasProfileError("The profile select not exits int the server. Error: %s" % e.message)
        except KeyError:
            raise OpenvasProfileError("The profile select not exits int the server")

        #
        # Create task
        #
        m_task_id     = None
        try:
            m_task_id = self.__manager.create_task(m_job_name, m_target_id, m_profile_id, comment="scan from golismero Openvas plugin")
        except ServerError, e:
            raise OpenvasTargetError("The target selected not exits in the server. Error: %s" % e.message)

        #
        # Start the scan
        #
        try:
            self.__manager.start_task(m_task_id)
        except ServerError, e:
            raise OpenvasServerError("Unknown error while try to start the task '%s'. Error: %s" % (m_task_id, e.message))

        return m_task_id


    #----------------------------------------------------------------------
    def get_results(self, scan_id):
        """
        Get the results associated to the scan ID

        :param scan_id: ID of scan to get.
        :type scan_id: str

        :return: list of OpenvasResult
        :rtype: list(OpenvasResult)
        """

        if not isinstance(scan_id, basestring):
            raise TypeError("Expected basestring, got '%s'" % type(scan_id))

        m_response = None
        try:
            self.__manager.xml('<get_results task_id="%s"/>' % scan_id, xml_result=True)
        except ServerError, e:
            raise OpenvasServerError("Can't get the results for the task %s. Error: %s" % (scan_id, e.message))

        return self._transform(r)

    #----------------------------------------------------------------------
    def stop_audit(self, scan_id):
        """"""
        raise NotImplemented("Not implemented yet")

    #----------------------------------------------------------------------
    @property
    def get_profiles(self):
        """
        :return: get a list with all profiles as a dict
        :rtype: {profile_name: ID}
        """
        return self.__manager.get_configs_ids()
    #----------------------------------------------------------------------
    @property
    def get_all_scans(self):
        """
        :return: get a list with all scans as a dict
        :rtype: {scan_name: ID}
        """
        return self.__manager.get_tasks_ids()

    #----------------------------------------------------------------------
    @property
    def get_running_scans(self):
        """
        :return: get a list of with all running scans
        :rtype: {scan_name: ID}
        """
        return self.__manager.get_tasks_ids_by_status("Running")

    #----------------------------------------------------------------------
    @property
    def get_finished_scans(self):
        """
        :return: get a list of with all finished scans
        :rtype: {scan_name: ID}
        """
        return self.__manager.get_tasks_ids_by_status("Done")

    #----------------------------------------------------------------------
    #
    # Transform Openvas results to GoLismero structures
    #
    #----------------------------------------------------------------------
    def _transform(self, xml_results):
        """
        Transfrom the XML results of OpenVas into GoLismero structures

        :param xml_results: input results, in XML format, from OpenVas.
        :type xml_results: list(Element)

        :return: List with the results in GoLismero format.
        :rtype: list(OpenvasResult)
        """
        PORT = re.compile("([\w\d\s]*)\(([\d]+)/([\w\W\d]+)\)")

        m_return         = []
        m_return_append  = m_return.append

        # All the results
        for l_results in xml_results.findall("results"):
            for l_results in l_results.findall("result"):
                l_partial_result = OpenvasResult.make_empty_object()

                # Store only High, Medium and Low threat
                if l_results.find("threat").text not in ("High","Medium", "Low"):
                    continue

                # For each result
                for l_val in l_results.getchildren():

                    l_tag = l_val.tag

                    if l_tag in ("subnet", "host", "threat", "description"):
                        # All text vars can be processes both.
                        setattr(l_partial_result, l_tag, l_val.text)
                    elif l_tag == "port":
                        # Extract and filter port info
                        l_port = PORT.findall(l_val.text)
                        if l_port and len(l_port) > 0:
                            if len(l_port[0]) == 3:
                                l_partial_result.port = OpenvasPort(l_port[0][0],
                                                                    int(l_port[0][1]),
                                                                    l_port[0][2])
                    elif l_tag == "nvt":
                        l_nvt_symbols = [x for x in dir(l_val) if not x.startswith("_")]
                        # The NVT Object
                        l_nvt_object  = OpenvasNVT.make_empty_object()
                        for l_nvt in l_val.getchildren():
                            l_nvt_tag = l_nvt.tag

                            if l_nvt_tag in l_nvt_symbols:
                                setattr(l_nvt_object, l_nvt_tag, l_nvt.text)

                        # Add to the NVT Object
                        l_partial_result.nvt = l_nvt_object
                    else:
                        pass

                # Add to the return values
                m_return_append(l_partial_result)

        return m_return











#
#
# Some code and ideas of the next code has been taken from the official
# OpenVas library:
#
# https://pypi.python.org/pypi/openvas.omplib
#
#
#

#------------------------------------------------------------------------------
#
# OMPv4 low level exceptions
#
#------------------------------------------------------------------------------
class Error(Exception):
    """Base class for OMP errors."""
    def __str__(self):
        return repr(self)

class _ErrorResponse(Error):
    def __init__(self, msg="", *args):

        self.message = msg

        super(_ErrorResponse, self).__init__(*args)

    def __str__(self):
        return self.message

class ClientError(_ErrorResponse):
    """command issued could not be executed due to error made by the client"""

class ServerError(_ErrorResponse):
    """error occurred in the manager during the processing of this command"""

class ResultError(Error):
    """Get invalid answer from Server"""
    def __str__(self):
        return 'Result Error: answer from command %s is invalid' % self.args

class AuthFailedError(Error):
    """Authentication failed."""

#------------------------------------------------------------------------------
#
# OMPv4 low level interface
#
#------------------------------------------------------------------------------
class OMPv4(object):
    """
    Internal manager for Openvas low level operations.

    ..note:
    	This class is based in the code borrowed from original OpenVas plugin:

    	https://pypi.python.org/pypi/openvas.omplib

    ..warning:

    	This manager follow the the OMP 4.0
    """


    TIMEOUT  = 10

    #----------------------------------------------------------------------
    def __init__(self):
        """"""
        self.socket  = None

    #----------------------------------------------------------------------
    @classmethod
    def open(cls, host, username, password, port=9390, timeout=None):
        """Open a connection to the manager and authenticate the user."""

        if not isinstance(host, basestring):
            raise TypeError("Expected basestring, got '%s'" % type(host))
        if not isinstance(username, basestring):
            raise TypeError("Expected basestring, got '%s'" % type(username))
        if isinstance(port, int):
            if not (0 < port < 65535):
                raise ValueError("Port must be between 0-65535")
        else:
            raise TypeError("Expected int, got '%s'" % type(port))
        if timeout:
            if not isinstance(timeout, int):
                raise TypeError("Expected int, got '%s'" % type(timeout))

        # Connect
        sock        = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        # Controls for timeout
        m_timeout   = OMPv4.TIMEOUT
        if timeout:
            m_timeout = timeout
        sock.settimeout(m_timeout)
        sock        = ssl.wrap_socket(sock)
        try:
            sock.connect((host, int(port)))
        except socket.error, e:
            raise ServerError("Error while connection to the server. Error: %s" % e.message)

        # Create and configure object
        cls         = OMPv4()
        cls.socket  = sock

        # Try to authenticate
        cls._authenticate(username, password)

        return cls

    #----------------------------------------------------------------------
    #
    # PUBLIC METHODS
    #
    #----------------------------------------------------------------------
    def close(self):
        """Close the connection to the manager"""
        self.socket.close()
        self.socket = None

    #----------------------------------------------------------------------
    def xml(self, xmldata, xml_result=False):
        """
        Low-level interface to send OMP XML to the manager.

        `xmldata` may be either a utf-8 encoded string or an etree
        Element. If `xml_result` is true, the result is returned as an
        etree Element, otherwise a utf-8 encoded string is returned.

        :param xmldata: string with the XML data.
        :type: xmldata: str

        :param xml_result: boolean that indicates if the response will be in XML format.
        :type xml_result: bool

        :return: a text/xml data from the server.
        :rtype: `ElementTree`

        :raises: RunTimeError, ClientError, ServerError
        """

        if xml_result:
            return self._xml_command(xmldata)
        else:
            return self._text_command(xmldata)

    def delete_task(self, task_id):
        """
        Delete a task in OpenVas server.

        :param task_id: task id
        :type task_id: str

        :raises: RunTimeError, ClientError, ServerError
        """

        request =  """<delete_task task_id="%s" />""" % (task_id)



    def create_task(self, name, target, config, comment):
        """
        Creates a task in OpenVas.

        :param name: name to the task
        :type name: str

        :param target: target to scan
        :type target: str

        :param config: config (profile) name
        :type config: str

        :param comment: comment to add to task
        :type comment: str

        :return: the ID of the task created.
        :rtype: str

        :raises: RunTimeError, ClientError, ServerError
        """

        request =  """<create_task>
	    <name>%s</name>
	    <comment>%s</comment>
	    <config id="%s"/>
	    <target id="%s"/>
	    </create_task>""" % (name, comment, config, target)

        return self.xml(request, xml_result=True).get("id")

    def create_target(self, name, hosts, comment=""):
        """
        Creates a target in OpenVas.

        :param name: name to the target
        :type name: str

        :param hosts: target list. Can be only one target or a list of targets
        :type hosts: str | list(str)

        :param comment: comment to add to task
        :type comment: str

        :return: the ID of the created target.
        :rtype: str

        :raises: RunTimeError, ClientError, ServerError
        """

        if isinstance(hosts, str):
            m_targets = hosts
        elif isinstance(hosts, Iterable):
            m_targets = ",".join(hosts)

        request =  """<create_target>
		<name>%s</name>
		<hosts>%s</hosts>
		<comment>%s</comment>
	    </create_target>""" % (name, m_targets, comment)

        return self.xml(request, xml_result=True).get("id")

    #----------------------------------------------------------------------
    def get_configs(self, config_id=None):
        """
        Get information about the configs in the server.

        If name param is provided, only get the config associated to this name.

        :param config_id: config id to get
        :type config_id: str

        :return: `ElementTree`

        :raises: RunTimeError, ClientError, ServerError
        """
        # Recover all config from Openvas
        if config_id:
            return self.xml('<get_configs config_id="%s"/>' % config_id, xml_result=True)
        else:
            return self.xml("<get_configs />", xml_result=True)


    #----------------------------------------------------------------------
    def get_configs_ids(self, name=None):
        """
        Get information about the configured profiles (configs)in the server.

        If name param is provided, only get the ID associated to this name.

        :param name: config name to get
        :type name: str

        :return: a dict with the format: {config_name: config_ID}

        :raises: RunTimeError, ClientError, ServerError
        """

        m_return = {}

        for x in self.get_configs().findall("config"):
            m_return[x.find("name").text] = x.get("id")

        if name:
            return {name : m_return[name]}
        else:
            return m_return


    #----------------------------------------------------------------------
    def get_tasks(self, task_id=None):
        """
        Get information about the configured profiles in the server.

        If name param is provided, only get the task associated to this name.

        :param task_id: task id to get
        :type task_id: str

        :return: `ElementTree`

        :raises: RunTimeError, ClientError, ServerError
        """
        # Recover all config from Openvas
        if task_id:
            return self.xml('<get_tasks id="%s"/>' % name, xml_result=True)
        else:
            return self.xml("<get_tasks/>", xml_result=True)



    #----------------------------------------------------------------------
    def get_tasks_ids(self, name=None):
        """
        Get IDs of tasks of the server.

        If name param is provided, only get the ID associated to this name.

        :param name: task name to get
        :type name: str

        :return: a dict with the format: {task_name: task_ID}

        :raises: RunTimeError, ClientError, ServerError
        """

        m_return = {}

        for x in self.get_tasks().findall("task"):
            m_return[x.find("name").text] = x.get("id")

        if name:
            return {name : m_return[name]}
        else:
            return m_return

    #----------------------------------------------------------------------
    def get_tasks_ids_by_status(self, status="Done"):
        """
        Get IDs of tasks of the server depending of their status.

        Allowed status are: "Done", "Paused", "Running", "Stopped".

        If name param is provided, only get the ID associated to this name.

        :param name: get task with this status
        :type name: str - ("Done" |"Paused" | "Running" | "Stopped".)

        :return: a dict with the format: {task_name: task_ID}

        :raises: RunTimeError, ClientError, ServerError
        """
        if status not in ("Done", "Paused", "Running", "Stopped"):
            raise ValueError("Requested status are not allowed")

        m_task_ids     = set()
        m_task_ids_add = m_task_ids.add

        for x in self.get_tasks().findall("task"):
            if x.find("status").text == status:
                m_task_ids_add(x.find("name").text)

        # Get the tasks
        m_return        = {}
        m_return_update = m_return.update
        for t_name in m_task_ids:
            m_return_update(self.get_tasks_ids(t_name))

        return m_return



    #----------------------------------------------------------------------
    def get_results(self, task_id=None):
        """
        Get the results associated to the scan ID

        :param task_id: ID of scan to get. All if not provided
        :type task_id: str

        :return: xml object
        :rtype: `ElementTree`

        :raises: RunTimeError, ClientError, ServerError
        """

        m_query = None
        if task_id:
            m_query = '<get_results task_id="%s"/>' % scan_id
        else:
            m_query = '<get_results/>'

        return self.__manager.xml(m_query, xml_result=True)


    #----------------------------------------------------------------------
    def start_task(self, task_id):
        """
        Start a task

        :param task_id: Id of task to start.
        :type task_id: str

        :raises: RunTimeError, ClientError, ServerError
        """
        if not isinstance(task_id, basestring):
            raise TypeError("Expected basestring, got '%s'" % type(task_id))

        m_query = '<start_task task_id="%s"/>' % task_id

        self.xml(m_query, xml_result=True)


    #----------------------------------------------------------------------
    #
    # PRIVATE METHODS
    #
    #----------------------------------------------------------------------
    def _authenticate(self, username, password):
        """
        Authenticate a user to the manager.

        :param username: user name
        :type username: str

        :param password: user password
        :type password: str

        :raises: AuthFailedError
        """
        if not isinstance(username, basestring):
            raise TypeError("Expected basestring, got '%s'" % type(username))
        if not isinstance(password, basestring):
            raise TypeError("Expected basestring, got '%s'" % type(password))

        m_request = """<authenticate>
		<credentials>
		  <username>%s</username>
		  <password>%s</password>
		</credentials>
	  </authenticate>""" % (username, password)

        try:
            self._text_command(m_request)
        except ClientError:
            raise AuthFailedError(username)

    def _send(self, data):
        """Send OMP data to the manager and read the result.

        `data` may be either an unicode string, an utf-8 encoded
        string or an etree Element. The result is as an etree Element.

        :param data: data to send.
        :type data: str| ElementTree

        :return: and xml tree.
        :rtype: `ElementTree`
        """
        BLOCK_SIZE = 1024
        if etree.iselement(data):
            root = etree.ElementTree(data)
            root.write(self.socket, 'utf-8')
        else:
            if isinstance(data, unicode):
                data = data.encode('utf-8')
            self.socket.send(data)
        parser = etree.XMLTreeBuilder()
        while 1:
            res = self.socket.recv(BLOCK_SIZE)
            parser.feed(res)
            if len(res) < BLOCK_SIZE:
                break
        root = parser.close()

        return root

    #----------------------------------------------------------------------
    def _check_response(self, response):
        """Check the response read from the manager.

        If the response status is 4xx a ClientError is raised, if the
        status is 5xx a ServerError is raised.

        :param response: ElementTree with the response
        :type response: ElementTree

        :return: status text
        :type: str

        :raises: RunTimeError, ClientError, ServerError
        """
        status = response.get('status')

        if status is None:
            raise RunTimeError('response is missing status: %s'
                               % etree.tostring(response))
        if status.startswith('4'):
            raise ClientError("[%s] %s: %s" % (status,
                                               response.tag,
                                               response.get('status_text')))

        elif status.startswith('5'):
            raise ServerError("[%s] %s: %s" %(status,
                                              response.tag,
                                              response.get('status_text')))

        return status


    #----------------------------------------------------------------------
    def _text_command(self, request):
        """
        Make a request and get the text of the response in raw format.

        :param request: the query.
        :type request: str

        :return: the response text.
        :rtype: str

        :raises: RunTimeError, ClientError, ServerError
        """
        response = self._send(request)
        self._check_response(response)
        return response.text

    #----------------------------------------------------------------------
    def _xml_command(self, request):
        """
        Make a request and get the response as xml tree format.

        :param request: the query.
        :type request: str

        :return: the response as xml tree.
        :rtype: `ElementTree`

        :raises: RunTimeError, ClientError, ServerError
        """
        response = self._send(request)
        self._check_response(response)
        return response