#!/usr/bin/python
# -*- coding: utf-8 -*-

"""

OpenVas manager library for OMP v4.0

This is a replacemente library of the official Openvas python library,
becasue the oficial library not work for the OMP v4.0

"""

__license__ = """
GoLismero 2.0 - The web knife - Copyright (C) 2011-2013

Authors:
  Daniel Garcia Garcia a.k.a cr0hn | cr0hn<@>cr0hn.com
  Mario Vilas | mvilas<@>gmail.com

Golismero project site: http://golismero-project.com
Golismero project mail: golismero.project<@>gmail.com


This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
"""

import socket
import ssl
from collections import Iterable
try:
	from xml.etree import cElementTree as etree
except ImportError:
	from xml.etree import ElementTree as etree
#import xml.dom.minidom

#------------------------------------------------------------------------------
#
# High level exceptions
#
#------------------------------------------------------------------------------
class OpenvasException(Exception):
	"""Base class Openvas exceptions"""
	pass
#------------------------------------------------------------------------------
class OpenvasAuthFail(OpenvasError):
	"""Authentication fail"""
	#----------------------------------------------------------------------
	def __init__(self, message):
		"""Constructor"""

		self.message = message

		super(OpenvasAuthFail, self).__init__()



#------------------------------------------------------------------------------
class OpenvasServerError(OpenvasError):
	"""Some generic error generated by the server"""
	#----------------------------------------------------------------------
	def __init__(self, message):
		"""Constructor"""

		self.message = message

		super(OpenvasServerError, self).__init__()


#------------------------------------------------------------------------------
class OpenvasClientError(OpenvasError):
	"""Some generic error generated by the client"""
	#----------------------------------------------------------------------
	def __init__(self, message):
		"""Constructor"""

		self.message = message

		super(OpenvasClientError, self).__init__()

#------------------------------------------------------------------------------
class OpenvasProfileError(OpenvasError):
	"""Profile error"""
	#----------------------------------------------------------------------
	def __init__(self, message):
		"""Constructor"""

		self.message = message

		super(OpenvasClientError, self).__init__()

#------------------------------------------------------------------------------
class OpenvasTargetError(OpenvasError):
	"""Target related errors"""
	#----------------------------------------------------------------------
	def __init__(self, message):
		"""Constructor"""

		self.message = message

		super(OpenvasClientError, self).__init__()

#------------------------------------------------------------------------------
class OpenvasTargetError(OpenvasError):
	"""Task related errors"""
	#----------------------------------------------------------------------
	def __init__(self, message):
		"""Constructor"""

		self.message = message

		super(OpenvasClientError, self).__init__()


#------------------------------------------------------------------------------
class OpenvasManager(object):
	"""
	High interface to mange OpenVas server.

	..warning:

	  This manager follow the the OMP 4.0

	"""

	TIMEOUT = 5

	#----------------------------------------------------------------------
	#
	# Methods to manage the OpenVas
	#
	#----------------------------------------------------------------------
	@classmethod
	def connect(cls, host, user, password, port=9390, timeout=None):
		"""
		Make the connection to the Openvas server and get a manager object.

		:param host: the host where the manager are running.
		:type host: str

		:param user: user name
		:type user: str

		:param password: the password
		:type password: str

		:param port: port where the server are listen.
		:type port: int

		:return: an OpenvasManager object
		:rtype: OpenvasManager
		"""
		if not isinstance(host, basestring):
			raise TypeError("Expected basestring, got '%s'" % type(host))
		if not isinstance(user, basestring):
			raise TypeError("Expected basestring, got '%s'" % type(user))
		if not isinstance(password, basestring):
			raise TypeError("Expected basestring, got '%s'" % type(password))
		if isinstance(port, int):
			if not (0 < port < 65535):
				raise ValueError("port must be between ranges: [0-65535]")
		else:
			raise TypeError("Expected int, got '%s'" % type(port))

		m_time_out = None
		if timeout:
			if isinstance(timeout, int):
				if timeout < 1:
					raise ValueError("timeout value must be greater than 0.")
				else:
					m_time_out = timeout
			pass:
				raise TypeError("Expected int, got '%s'" % type(timeout))

		cls                    = OpenvasManager()

		# Create the manager
		try:
			cls.__manager          = OMPv4.open(host, user, password, port, m_time_out)
		except ServerError:
			raise OpenvasServerError("Error while connecting to the server")
		except AuthFailedError:
			raise OpenvasAuthFail("Error while trying to authenticate into the server.")

		return cls

	#----------------------------------------------------------------------
	def launch_scan(self, target, profile = "Full and fast"):
		"""
		Launch a new audit in the OpenVas

		:param target: target to audit
		:type target: str

		:param profile: scan profile in the Openvas server
		:type profile: str

		:return: ID of the audit
		:rtype: str
		"""
		if not (isinstance(target, basestring) or isinstance(target, Iterable)):
			raise TypeError("Expected basestring or iterable, got '%s'" % type(target))
		if not isinstance(profile, basestring):
			raise TypeError("Expected basestring, got '%s'" % type(profile))


		#
		# Generate the random names used
		#
		m_target_name = "golismero_target_%s" % generate_random_string(20)
		m_job_name    = "golismero_job_%s" % generate_random_string(20)

		#
		# Create the target
		#
		try:
			self.__manager.create_target(m_target_name, target, "Temportal target from golismero Openvas plugin")
		except ServerError:
			raise OpenvasTargetError("The target already exits on the server")

		# Get the profile Id by their name
		m_profile_id      = None
		try:
			tmp           = self.__manger.get_configs_ids(profile)
			m_profile_id  = tmp[profile]
		except ServerError:
			raise OpenvasProfileError("The profile select not exits int the server")
		except KeyError:
			raise OpenvasProfileError("The profile select not exits int the server")

		#
		# Create task
		#
		m_task_id     = None
		try:
			m_task_id = self.__manager.create_target(m_job_name, m_target_name, m_profile_id, "scan from golismero Openvas plugin")
		except ServerError:
			raise OpenvasTargetError("The target selected not exits in the server.")

		#
		# Start the scan
		#
		try:
			self.__manager.start_task(m_task_id)
		except ServerError, e:
			raise OpenvasServerError("Unknown error while try to start the task '%s'. Error: %s" % (m_task_id, e.message))

		return m_task_id


	#----------------------------------------------------------------------
	def get_results(self, scan_id):
		"""
		Get the results associated to the scan ID

		:param scan_id: ID of scan to get.
		:type scan_id: str

		:return: list of OpenvasResult
		:rtype: list(OpenvasResult)
		"""

		if not isinstance(scan_id, basestring):
			raise TypeError("Expected basestring, got '%s'" % type(scan_id))

		m_response = None
		try:
			self.__manager.xml('<get_results task_id="%s"/>' % scan_id, xml_result=True)
		except ServerError:
			raise OpenvasServerError("Can't get the results for the task %s" % scan_id)

		return self._transform(r)

	#----------------------------------------------------------------------
	def stop_audit(self, scan_id):
		""""""
		raise NotImplemented("Not implemented yet")

	#----------------------------------------------------------------------
	#
	# Transform Openvas results to GoLismero structures
	#
	#----------------------------------------------------------------------
	def _transform(self, xml_results):
		"""
		Transfrom the XML results of OpenVas into GoLismero structures

		:param xml_results: input results, in XML format, from OpenVas.
		:type xml_results: list(Element)

		:return: List with the results in GoLismero format.
		:rtype: list(OpenvasResult)
		"""
		PORT = re.compile("([\w\d\s]*)\(([\d]+)/([\w\W\d]+)\)")

		m_return         = []
		m_return_append  = m_return.append

		# All the results
		for l_results in xml_results.findall("results"):
			for l_results in l_results.findall("result"):
				l_partial_result = OpenvasResult.make_empty_object()

				# Store only High, Medium and Low threat
				if l_results.find("threat").text not in ("High","Medium", "Low"):
					continue

				# For each result
				for l_val in l_results.getchildren():

					l_tag = l_val.tag

					if l_tag in ("subnet", "host", "threat", "description"):
						# All text vars can be processes both.
						setattr(l_partial_result, l_tag, l_val.text)
					elif l_tag == "port":
						# Extract and filter port info
						l_port = PORT.findall(l_val.text)
						if l_port and len(l_port) > 0:
							if len(l_port[0]) == 3:
								l_partial_result.port = OpenvasPort(l_port[0][0],
																    int(l_port[0][1]),
																    l_port[0][2])
					elif l_tag == "nvt":
						l_nvt_symbols = [x for x in dir(l_val) if not x.startswith("_")]
						# The NVT Object
						l_nvt_object  = OpenvasNVT.make_empty_object()
						for l_nvt in l_val.getchildren():
							l_nvt_tag = l_nvt.tag

							if l_nvt_tag in l_nvt_symbols:
								setattr(l_nvt_object, l_nvt_tag, l_nvt.text)

						# Add to the NVT Object
						l_partial_result.nvt = l_nvt_object
					else:
						pass

				# Add to the return values
				m_return_append(l_partial_result)

		return m_return









#
#
# Some code and ideas of the next code has been taken from the official
# OpenVas library:
#
# https://pypi.python.org/pypi/openvas.omplib
#
#
#

#------------------------------------------------------------------------------
#
# OMPv4 low level exceptions
#
#------------------------------------------------------------------------------
class Error(Exception):
	"""Base class for OMP errors."""
	def __str__(self):
		return repr(self)

class _ErrorResponse(Error):
	def __init__(self, cmd, *args):
		if cmd:
			if cmd.endswith('_response'):
				cmd = cmd[:-9]
			super(_ErrorResponse, self).__init__(cmd, *args)
		else:
			super(_ErrorResponse, self).__init__(*args)

	def __str__(self):
		return '%s %s' % self.args[1:3]

class ClientError(_ErrorResponse):
	"""command issued could not be executed due to error made by the client"""

class ServerError(_ErrorResponse):
	"""error occurred in the manager during the processing of this command"""

class ResultError(Error):
	"""Get invalid answer from Server"""
	def __str__(self):
		return 'Result Error: answer from command %s is invalid' % self.args

class AuthFailedError(Error):
	"""Authentication failed."""

#------------------------------------------------------------------------------
#
# OMPv4 low level interface
#
#------------------------------------------------------------------------------
class OMPv4(object):
	"""
	Internal manager for Openvas low level operations.

	..note:
		This class is based in the code borrowed from original OpenVas plugin:

		https://pypi.python.org/pypi/openvas.omplib

	..warning:

		This manager follow the the OMP 4.0
	"""


	TIMEOUT  = 3

	#----------------------------------------------------------------------
	def __init__(self):
		""""""
		self.socket  = None

	#----------------------------------------------------------------------
	@staticmethod
	def open(cls, host, username, password, port=9390, timeout=None):
		"""Open a connection to the manager and authenticate the user."""

		# Connect
		sock        = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
		# Controls for timeout
		m_timeout   = OMPv4.TIMEOUT
		if timeout:
			m_timeout = timeout
		sock.settimeout(m_timeout)
		sock        = ssl.wrap_socket(sock)
		try:
			sock.connect((host, port))
		except socket.error:
			raise ServerError()

		# Create and configure object
		cls         = OMPv4()
		cls.socket  = sock

		# Try to authenticate
		cls._authenticate(username, password)

	#----------------------------------------------------------------------
	#
	# PUBLIC METHODS
	#
	#----------------------------------------------------------------------
	def close(self):
		"""Close the connection to the manager"""
		self.socket.close()
		self.socket = None

	#----------------------------------------------------------------------
	def xml(self, xmldata, xml_result=False):
		"""
		Low-level interface to send OMP XML to the manager.

		`xmldata` may be either a utf-8 encoded string or an etree
		Element. If `xml_result` is true, the result is returned as an
		etree Element, otherwise a utf-8 encoded string is returned.

		:param xmldata: string with the XML data.
		:type: xmldata: str

		:param xml_result: boolean that indicates if the response will be in XML format.
		:type xml_result: bool

		:return: a text/xml data from the server.
		:rtype: `ElementTree`

		:raises: RunTimeError, ClientError, ServerError
		"""

		if xml_result:
			return self._xml_command(xmldata)
		else:
			return self._text_command(xmldata)

	def create_task(self, name, target, config, comment):
		"""
		Creates a task in OpenVas.

		:param name: name to the task
		:type name: str

		:param target: target to scan
		:type target: str

		:param config: config (profile) name
		:type config: str

		:param comment: comment to add to task
		:type comment: str

		:return: the ID of the task created.
		:rtype: str

		:raises: RunTimeError, ClientError, ServerError
		"""

		request =  """<create_task>
	    <name>%s</name>
	    <comment>%s</comment>
	    <config id="%s"/>
	    <target id="%s"/>
	    </create_task>""" % (name, comment, profile, target)

		return self.__manager.xml(request, xml_result=True).get("id")

	def create_target(self, name, hosts, comment=""):
		"""
		Creates a target in OpenVas.

		:param name: name to the target
		:type name: str

		:param hosts: target list. Can be only one target or a list of targets
		:type hosts: str | list(str)

		:param comment: comment to add to task
		:type comment: str

		:return: the ID of the created target.
		:rtype: str

		:raises: RunTimeError, ClientError, ServerError
		"""

		if isinstance(target, str):
			m_targets = hosts
		elif isinstance(target, Iterable):
			m_targets = ",".join(hosts)

		request =  """<create_target>
		<name>%s</name>
		<hosts>%s</hosts>
		<comment>%s</comment>
	    </create_target>""" % (name, m_targets, comment)

		return self.__manager.xml(request, xml_result=True).get("id")


			#<create_target>
				#<name>All GNU/Linux machines</name>
				#<hosts>192.168.1.0/24</hosts>
			#</create_target>


	#----------------------------------------------------------------------
	def get_configs(self, config_id=None):
		"""
		Get information about the configs in the server.

		If name param is provided, only get the config associated to this name.

		:param config_id: config id to get
		:type config_id: str

		:return: `ElementTree`

		:raises: RunTimeError, ClientError, ServerError
		"""
		# Recover all config from Openvas
		if name:
			return self.xml('<get_configs config_id="%s"/>' % name, xml_result=True)
		else:
			return self.xml("<get_configs/>", xml_result=True)


	#----------------------------------------------------------------------
	def get_configs_ids(self, name=None):
		"""
		Get information about the configured profiles (configs)in the server.

		If name param is provided, only get the ID associated to this name.

		:param name: config name to get
		:type name: str

		:return: a dict with the format: {config_name: config_ID}

		:raises: RunTimeError, ClientError, ServerError
		"""

		m_return = {}
		for x in self.get_configs():
			m_return[x.find("name").text] = x.get("id")

		if name:
			return {name : m_return[name]}
		else:
			return m_return


	#----------------------------------------------------------------------
	def get_tasks(self, task_id=None):
		"""
		Get information about the configured profiles in the server.

		If name param is provided, only get the task associated to this name.

		:param task_id: task id to get
		:type task_id: str

		:return: `ElementTree`

		:raises: RunTimeError, ClientError, ServerError
		"""
		# Recover all config from Openvas
		if name:
			return self.xml('<get_tasks id="%s"/>' % name, xml_result=True)
		else:
			return self.xml("<get_tasks/>", xml_result=True)



	#----------------------------------------------------------------------
	def get_tasks_ids(self, name=None):
		"""
		Get IDs of tasks of the server.

		If name param is provided, only get the ID associated to this name.

		:param name: task name to get
		:type name: str

		:return: a dict with the format: {task_name: task_ID}

		:raises: RunTimeError, ClientError, ServerError
		"""

		m_return = {}

		for x in self.get_tasks():
			m_return[x.find("name").text] = x.get("id")

		if name:
			return {name : m_return[name]}
		else:
			return m_return


	#----------------------------------------------------------------------
	def get_results(self, task_id=None):
		"""
		Get the results associated to the scan ID

		:param task_id: ID of scan to get. All if not provided
		:type task_id: str

		:return: xml object
		:rtype: `ElementTree`

		:raises: RunTimeError, ClientError, ServerError
		"""

		m_query = None
		if task_id:
			m_query = '<get_results task_id="%s"/>' % scan_id
		else:
			m_query = '<get_results/>'

		return self.__manager.xml(m_query, xml_result=True)


	#----------------------------------------------------------------------
	def start_task(self, task_id):
		"""
		Start a task

		:param task_id: Id of task to start.
		:type task_id: str

		:raises: RunTimeError, ClientError, ServerError
		"""
		if not isinstance(task_id, basestring):
			raise TypeError("Expected basestring, got '%s'" % type(task_id))

		m_query = '<start_task task_id="%s"/>' % task_id

		self.xml(m_query, xml_result=True)


	#----------------------------------------------------------------------
	#
	# PRIVATE METHODS
	#
	#----------------------------------------------------------------------
	def _authenticate(self, username, password):
		"""
		Authenticate a user to the manager.

		:param username: user name
		:type username: str

		:param password: user password
		:type password: str

		:raises: AuthFailedError
		"""
		if not isinstance(username, basestring):
			raise TypeError("Expected basestring, got '%s'" % type(username))
		if not isinstance(password, basestring):
			raise TypeError("Expected basestring, got '%s'" % type(password))

		m_request = """<authenticate>
		<credentials>
		  <username>%s</username>
		  <password>%s</password>
		</credentials>
	  </authenticate>""" % (username, password)

		try:
			self._text_command(m_request)
		except ClientError:
			raise AuthFailedError(username)

	def _send(self, data):
		"""Send OMP data to the manager and read the result.

		`data` may be either an unicode string, an utf-8 encoded
		string or an etree Element. The result is as an etree Element.

		:param data: data to send.
		:type data: str| ElementTree

		:return: and xml tree.
		:rtype: `ElementTree`
		"""
		BLOCK_SIZE = 1024
		if etree.iselement(data):
			#print '>>>', etree.tostring(data)
			root = etree.ElementTree(data)
			root.write(self.socket, 'utf-8')
		else:
			if isinstance(data, unicode):
				data = data.encode('utf-8')
			self.socket.send(data)
		parser = etree.XMLTreeBuilder()
		while 1:
			res = self.socket.recv(BLOCK_SIZE)
			#print repr(res)
			parser.feed(res)
			if len(res) < BLOCK_SIZE:
				break
		root = parser.close()

		return root

	#----------------------------------------------------------------------
	def _check_response(self, response):
		"""Check the response read from the manager.

		If the response status is 4xx a ClientError is raised, if the
		status is 5xx a ServerError is raised.

		:param response: ElementTree with the response
		:type response: ElementTree

		:return: status text
		:type: str

		:raises: RunTimeError, ClientError, ServerError
		"""
		status = response.get('status')

		if status is None:
			raise RunTimeError('response is missing status: %s'
						       % etree.tostring(response))
		if status.startswith('4'):
			raise ClientError(response.tag, status,
						      response.get('status_text'))
		elif status.startswith('5'):
			raise ServerError(response.tag, status,
						      response.get('status_text'))
		return status


	#----------------------------------------------------------------------
	def _text_command(self, request):
		"""
		Make a request and get the text of the response in raw format.

		:param request: the query.
		:type request: str

		:return: the response text.
		:rtype: str

		:raises: RunTimeError, ClientError, ServerError
		"""
		response = self._send(request)
		self._check_response(response)
		return response.text

	#----------------------------------------------------------------------
	def _xml_command(self, request):
		"""
		Make a request and get the response as xml tree format.

		:param request: the query.
		:type request: str

		:return: the response as xml tree.
		:rtype: `ElementTree`

		:raises: RunTimeError, ClientError, ServerError
		"""
		response = self._send(request)
		self._check_response(response)
		return response